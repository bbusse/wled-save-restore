#!/usr/bin/env bash
#
# wled-save-restore
#
# Backup and restore WLED configuration and presets
#
# Copyright (c) Bj√∂rn Busse (bj.rn@baerlin.eu)
# SPDX-License-Identifier: BSD-3-Clause
#

#optional_dependencies=("git" "jq" "matcha" "mdns-discover")

url_repo_mdns_discover="github.com/bbusse/mdns-discover@latest"
url_repo_matcha="github.com/emersion/matcha/cmd/matcha@latest"
url_src_matcha="https://github.com/emersion/matcha/archive/refs/tags/v0.1.0.tar.gz"

show_usage() {
    printf "\n"
    printf " wled-save-restore\n"
    printf "\n"
    printf " Usage:\n"
    printf "\n"
    printf "   wled-save-restore help                            Show usage\n"
    printf "   wled-save-restore save HOST                       Backup configuration and presets\n"
    printf "   wled-save-restore save HOST INTERVAL_MINUTES      Backup configuration and presets\n"
    printf "                                                     every x minutes\n"
    printf "   wled-save-restore restore config JSON_FILE HOST   Restore configuration\n"
    printf "   wled-save-restore restore presets JSON_FILE HOST  Restore preset\n"
    printf "\n"
    printf " Environment Variables\n"
    printf "\n"
    printf "   WSR_BACKUP_PATH           The path to save backup files to\n"
    printf "   WSR_BACKUP_INTERVAL_MINS  The backup interval in minutes\n"
    printf "   WSR_USE_GIT               Use git as backend\n"
    printf "   WSR_GIT_USER              The git user to use\n"
    printf "   WSR_GIT_MAIL              The git mail address to use\n"
    printf "   WSR_GIT_COMMIT_MSG        The git commit message to use\n"
    printf "   WSR_AUTODISCOVER          Use mDNS service discovery to find devices\n"
    printf "   WSR_HTTP_SERVE_BACKUPS    Serve backup files\n"
    printf "   WSR_HTTP_SERVER_ADDRESS   Server address for serving backups\n"
    printf "\n"
}

mdns_search() {
    local r

    r=$(MDNS_SERVICE_FILTER="_wled._tcp" mdns-discover | awk '{print $3}')
    echo "$r"
}

parse_hosts() {
    local hosts
    hosts="$1"

    set -f
    IFS=$'\n'
    read -a a <<< "$hosts"
    echo "$hosts"
}

fetch_json() {
    local url
    url="$1"
    local file_output
    file_output="$2"
    local format_json
    format_json="$3"
    local r

    # Formatting seems to break WLED - needs testing
    # https://github.com/Aircoookie/WLED/issues/3139
    if [ "$format_json" -eq 1 ]; then
        r=$(curl -s --output - "$url" | jq)
    else
        r=$(curl -s --output - "$url")
    fi

    printf "%s" "$r" > "$file_output"
}

post_json() {
    local host
    host="$1"
    local file
    file="$2"
    local r

    # Make a temporary copy to original filename for upload
    cp "$HOME/.config/wled/wled_lights-bed-0.cfg.json" cfg.json

    r=$(curl -w " %{http_code}" \
             --silent \
             --request POST \
             -F name=data \
             -F filename=@cfg.json \
             -F data=@ \
             "http://$host/upload")
    echo "$r"
}

reboot_device() {
    local host
    host="$1"

    printf "wsr: Rebooting device: %s\n" "$host"
    r=$(curl --silent \
             --header "Content-Type: application/json" \
             --request POST \
             --data '{"rb":true}' \
             "http://$host/json/state")
    echo "$r"
}

save() {
    local host
    host="$1"
    local path
    path="$2"
    local use_git
    use_git="$3"
    local git_commit_msg
    git_commit_msg="$4"

    printf "wsr: Fetching config and presets from %s\n" "$host"

    local hosts
    hosts=$(parse_hosts "$host")

    for h in $hosts; do
        fetch_json "http://$h/cfg.json" "$path/wled_$h.cfg.json" 0
        fetch_json "http://$h/presets.json" "$path/wled_$h.presets.json" 0
    done

    if [ "1" = "$use_git" ]; then
        printf "%s\n" "wsr: Saving changes"
        git_commit "$path" "$git_commit_msg"
    fi
}

git_init() {
    local path
    path="$1"
    local user
    user="$2"
    local mail
    mail="$3"

    cd "$path" || exit 1

    r=$(git rev-parse --is-inside-work-tree 2>/dev/null)

    if [ "$r" != "true" ]; then
        printf "%s\n" "wsr: Creating repository"
        git init >/dev/null 2>&1
        git config user.name "$user"
        git config user.email "$mail"
        git config init.defaultBranch main
    fi
}

git_ignore() {
    local path
    path="$1"
    local ignore
    ignore="$2"

    printf "%s\n" "$ignore" >> .gitignore
    git config advice.addIgnoredFile false
}

git_commit() {
    local path
    path="$1"
    local msg
    msg="$2"

    cd "$path" || exit 1

    git add .
    git commit -m "$msg"
}

go_install_prompt() {
    local pname
    pname="$1"
    local pkg
    pkg="$2"
    local path
    path="$3"
    local opt
    opt="$4"


    local prompt
    prompt=$(printf "%s: Do you want to install %s? Y/n " "$pname" "$pkg")
    local answer

    while true; do
        read -p "$prompt" answer
        case $answer in
            "")
            ;&
            [Yy]* )
              go install "$path"
              break;;
            [Nn]* )
              exit;;
            * ) echo "Please answer yes or no.";;
        esac
    done
}

noautodiscover_abort() {
    local url
    url="$1"

    printf "%s\n" "wsr: mdns-discover not found. Skipping autodiscovery"
    printf "%s\n" "wsr: You can install it with:"
    printf "%s\n" "wsr: \`go install $url_repo_mdns_discover\`"
    printf "%s\n" "wsr: Please specify a host to connect to"
    printf "%s\n" "wsr: Aborting.."
    exit 1
}

autodiscover_fail_abort() {
    printf "wsr: Autodiscovery found no devices\n"
    printf "wsr: Please specify a host to connect to\n"
    printf "%s\n" "wsr: Aborting.."
    exit 1
}

prepare_webroot() {
    local path
    path="$1"
    local pkg_archive
    pkg_archive="v0.1.0.tar.gz"

    if cd "$path"; then

        # Fetch htdocs
        curl -sS -O --output-dir "$path" "${url_src_matcha}"
        if tar xf "$pkg_archive"; then
            rm "$pkg_archive"
            echo 0
        else
            echo 1
        fi
    else
        echo 1
    fi
}

prepare_webserver() {
    local path
    path="$1"

    go_install_prompt "wsr" "matcha" "$url_repo_matcha"

    # Fetch and extract htdocs
    local r
    r=$(prepare_webroot "$path")

    if [ "$r" -eq 0 ]; then
        if command -v matcha >/dev/null 2>&1; then
            # matcha exists
            # Copy matcha binary to wled config backup path if installed
            local matcha
            matcha=$(command -v matcha)
            if cp "$matcha" "$path"; then
                echo 0
            else
                echo 1
            fi
        else
            echo 1
        fi
    else
        echo 1
    fi
 }

start_webserver() {
    local address
    address="$1"
    local path
    path="$2"

    cd "$path" || exit 1

    if stat matcha >/dev/null 2>&1; then
        ADDRESS="${address}"
        ./matcha 1>/dev/null &
        printf "wsr: Serving %s\n" "$path"
        printf "wsr: Backups available at: http://%s\n" "$address"
    else
        printf "%s\n" "wsr: matcha not found in current directory "
        local r
        r=$(prepare_webserver "$path")
        echo $r
        if [ "$r" -eq 0 ]; then
            start_webserver "$address" "$path"
        fi
    fi
}

main() {
    local action
    action="$1"
    local path
    path="${WSR_BACKUP_PATH:=$HOME/.config/wled}"
    local use_git
    use_git="${WSR_USE_GIT:=1}"
    local git_user
    git_user="${WSR_GIT_USER:=wsr}"
    local git_mail
    git_mail="${WSR_GIT_MAIL:=wsr@localhost}"
    local git_commit_msg
    git_commit_msg="${WSR_GIT_COMMIT_MSG:="wsr: Backup config and presets"}"
    local serve_files
    serve_files="${WSR_HTTP_SERVE_FILES:=1}"
    local server_address
    server_address="${WSR_HTTP_ADDRESS:=[::1]:8080}"

    # We use autodiscover if no host are supplied
    # on the command line
    local use_autodiscover
    use_autodiscover=0

    if [ -z "$action" ]; then
        show_usage
        printf "wsr: Please specify an action: One of 'save' or 'restore'\n"
        printf "wsr: Aborting..\n"
        exit 1
    fi

    if [ "help" = "$action" ]; then
        show_usage
        exit 0
    fi

    mkdir -p "$path"

    if [ "$use_git" -eq 1 ]; then
        git_init "$path" "$git_user" "$git_mail"
        git_ignore "$path" ".gitignore"
        git_ignore "$path" "matcha"
        git_ignore "$path" "public/"
    fi

    # Restore config or presets
    if [ "restore" = "$action" ]; then
        local what
        what="$2"
        local file
        file="$3"

        if [ "presets" != "$what" ] && [ "config" != "$what" ]; then
            if [ -z "$what" ]; then
                printf "wsr: Please specify a resource to restore: One of presets or config\n"
                printf "wsr: Aborting..\n"
                exit 1
            else
                printf "wsr: %s is not a valid resource: Must be one of presets or config\n" "$what"
                printf "wsr: Aborting..\n"
                exit 1
            fi
        fi

        if [ -z "$file" ]; then
            printf "wsr: Please specify a file to restore\n"
            printf "wsr: Aborting..\n"
            exit 1
        fi

        local host
        host="$4"

        if [ -z "$host" ]; then
            printf "wsr: Please specify a host to connect to\n"
            printf "wsr: Aborting..\n"
            exit 1
        fi

        printf "wsr: Restoring %s %s to %s\n" "$what" "$file" "$host"
        r=$(post_json "$host" "$file")
        printf "wsr: %s\n" "$r"
        r=$(reboot_device "$host")
        printf "wsr: %s\n" "$r"

        # Remove temporary copy
        rm cfg.json
        printf "wsr: Done\n"
        exit 0

    # Backup config and presets: one-shot or periodically
    elif [ "save" = "$action" ] || [ "save-periodically" = "$action" ]; then
        local host

        if [ "save" = "action" ]; then
            host="$2"
        else
            host="$3"
        fi

        if [ -z "$host" ]; then
            if ! command -v mdns-discover 1>/dev/null; then
                go_install_prompt "wsr" "mdns-discover" "$url_repo_mdns_discover"
                if ! command -v "mdns-discover" 1>/dev/null; then
                    noautodiscover_abort
                fi
                use_autodiscover=1
            fi

            printf "wsr: Looking for devices\n"
            host=$(mdns_search)
            if [ -n "$host" ]; then
                printf "wsr: Found devices:\n%s\n" "$host"
            else
                # Fail if no devices found
                autodiscover_fail_abort
            fi
        fi
    fi

    if [ "save" = "$action" ]; then
        hosts=$(parse_hosts "$host")
        save "$hosts" "$path" "$use_git" "$git_commit_msg"

    # Backup config and presets: periodically
    elif [ "save-periodically" = "$action" ]; then
        local t_interval_mins
        t_interval_mins="$2"
        local host
        host="$3"
        local t_start
        t_start=$(date -u)

        # Start webserver
        if [ "$serve_files" -eq 1 ]; then
            start_webserver "$server_address" "$path"
        fi

        if [ -z "$t_interval_mins" ]; then
            # No interval given, use default
            t_interval_mins=${WSR_BACKUP_INTERVAL_MINS:=3600}
            printf "wsr: No interval given, defaulting to %s minutes\n" "$WSR_BACKUP_INTERVAL_MINS"
        fi

        if ! [ "$t_interval_mins" -gt 0 ] 2> /dev/null; then
            printf "wsr: Invalid interval: %s. Need a number in minutes\n" "$t_interval_mins"
            printf "wsr: Aborting..\n"
            exit 1
        else
            local t_interval_seconds
            t_interval_seconds=$((t_interval_mins * 60))
            declare -i n=0
            declare -i next=0

            # Backup data periodically with given interval
            # Use results from autodiscovery if hosts not given explicitly
            while true; do
                n+=1

                if [ "$use_autodiscover" -eq 1 ]; then
                    # We found devices initially,
                    # do not not fail if we do not find any now
                    if [ "$n" -gt 1 ]; then
                        host=$(mdns_search)
                        hosts=$(parse_hosts "$host")
                    fi
                fi

                save "$hosts" "$path" "$use_git" "$git_commit_msg"

                next=n+1
                printf "wsr: >>> Next backup (%s) in %s second(s)\n" \
                       "$next" \
                       "$t_interval_seconds"
                printf "wsr: >>> Running since %s\n" "$t_start"
                printf "wsr: >>> Backing up %s device(s)\n" "${#hosts[@]}"

                sleep $t_interval_seconds
            done
        fi
    fi
}

main "$@"
